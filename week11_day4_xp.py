# -*- coding: utf-8 -*-
"""Week11/day4/xp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wB2ti_YngkRwxH0X6oQE9dKsHM3gaVQY

Exercise 1
"""

import numpy as np

# Create a 3x3 matrix
matrix = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [6, 8, 9]])

# 1. Calculate the determinant
determinant = np.linalg.det(matrix)

# 2. Find the inverse of the matrix
try:
    inverse = np.linalg.inv(matrix)
except np.linalg.LinAlgError:
    inverse = "The matrix is singular and doesn't have an inverse."

# Print the results
print("Original Matrix:")
print(matrix)

print("\nDeterminant:")
print(determinant)

print("\nInverse:")
print(inverse)

"""Exercise 2"""

import numpy as np

# Generate an array of 50 random numbers
random_array = np.random.rand(50)

# 1. Calculate the mean and median
mean = np.mean(random_array)
median = np.median(random_array)

# 2. Calculate the standard deviation
std_dev = np.std(random_array)

# Print the results
print("Random Array:")
print(random_array)

print("\nMean:", mean)
print("Median:", median)
print("Standard Deviation:", std_dev)

"""Exercise 3"""

import numpy as np
import pandas as pd

# Create a date range for January 2023
start_date = np.datetime64('2023-01-01')
end_date = np.datetime64('2023-01-31')
dates = np.arange(start_date, end_date + 1)

# Convert dates to YYYY/MM/DD format
formatted_dates = pd.to_datetime(dates).strftime('%Y/%m/%d')

# Print the original and formatted dates
print("Original dates:")
print(dates)

print("\nFormatted dates (YYYY/MM/DD):")
print(formatted_dates)

"""Exercise 4

"""

import numpy as np
import pandas as pd


# Create a DataFrame with random numbers
df = pd.DataFrame({
    'A': np.random.randint(1, 100, 20),
    'B': np.random.randint(1, 100, 20),
    'C': np.random.randint(1, 100, 20)
})

# 1. Conditional selection of data
condition = df['A'] > 50
selected_data = df[condition]

# 2. Aggregation functions
sum_values = df.sum()
average_values = df.mean()

# Print results
print("Original DataFrame:")
print(df)

print("\nConditional Selection (A > 50):")
print(selected_data)

print("\nSum of each column:")
print(sum_values)

print("\nAverage of each column:")
print(average_values)

"""Exercise 5"""

import numpy as np
import matplotlib.pyplot as plt

# Create a 5x5 grayscale image
image = np.array([
    [0,   50,  100, 150, 200],
    [50,  100, 150, 200, 250],
    [100, 150, 200, 250, 200],
    [150, 200, 250, 200, 150],
    [200, 250, 200, 150, 100]
], dtype=np.uint8)

# Print the array
print("Image array:")
print(image)

# Display the image
plt.imshow(image, cmap='gray')
plt.colorbar()
plt.title('5x5 Grayscale Image')
plt.show()

"""Exercise 6"""

import numpy as np


# Productivity scores of employees before the training program
productivity_before = np.random.normal(loc=50, scale=10, size=30)

# Productivity scores of the same employees after the training program
productivity_after = productivity_before + np.random.normal(loc=5, scale=3, size=30)

# Hypothesis:
# The training program has significantly increased employee productivity.

# To test this hypothesis, we'll use a paired t-test approach.
# We'll calculate the mean difference and its standard error.

# Calculate the difference in productivity
productivity_difference = productivity_after - productivity_before

# Calculate the mean difference
mean_difference = np.mean(productivity_difference)

# Calculate the standard error of the mean difference
se_difference = np.std(productivity_difference, ddof=1) / np.sqrt(len(productivity_difference))

# Calculate the t-statistic
t_statistic = mean_difference / se_difference

# Degrees of freedom
df = len(productivity_difference) - 1

# Print results
print(f"Mean productivity before training: {np.mean(productivity_before):.2f}")
print(f"Mean productivity after training: {np.mean(productivity_after):.2f}")
print(f"Mean improvement: {mean_difference:.2f}")
print(f"Standard error of improvement: {se_difference:.2f}")
print(f"T-statistic: {t_statistic:.2f}")
print(f"Degrees of freedom: {df}")

# Interpretation based on t-statistic
if t_statistic > 2:
    print("\nConclusion: The training program appears to have significantly increased employee productivity.")
else:
    print("\nConclusion: There's not enough evidence to conclude that the training program significantly increased employee productivity.")

"""Exercise 7"""

import numpy as np


# Create two arrays of the same shape with random integers
array1 = np.random.randint(1, 100, size=10)
array2 = np.random.randint(1, 100, size=10)

# Perform element-wise comparison
comparison_result = array1 > array2

# Print the arrays and the comparison result
print("Array 1:")
print(array1)

print("\nArray 2:")
print(array2)

print("\nElement-wise comparison (Array1 > Array2):")
print(comparison_result)

"""Exercise 8"""

import pandas as pd
import numpy as np


# Generate daily time series data for 2023
date_range = pd.date_range(start='2023-01-01', end='2023-12-31', freq='D')
data = np.random.randint(0, 100, size=len(date_range))

# Create a pandas Series with the date range as index
time_series = pd.Series(data, index=date_range)

# Function to slice and display data for a specific quarter
def display_quarter(series, start_month, end_month, quarter_name):
    quarter_data = series[f'2023-{start_month:02d}':f'2023-{end_month:02d}']
    print(f"\n{quarter_name}:")
    print(quarter_data)
    print(f"Mean value: {quarter_data.mean():.2f}")

# Display the entire series
print("Full 2023 Time Series:")
print(time_series)

# Slice and display data for each quarter
display_quarter(time_series, 1, 3, "First Quarter (January to March)")
display_quarter(time_series, 4, 6, "Second Quarter (April to June)")
display_quarter(time_series, 7, 9, "Third Quarter (July to September)")
display_quarter(time_series, 10, 12, "Fourth Quarter (October to December)")

# Demonstrate more specific slicing
print("\nSpecific date range (February 15 to March 15):")
specific_range = time_series['2023-02-15':'2023-03-15']
print(specific_range)

# Correct way to get every Monday in May
print("\nEvery Monday in May:")
may_mondays = time_series['2023-05'][time_series['2023-05'].index.dayofweek == 0]
print(may_mondays)

"""Exercise 9"""

import numpy as np
import pandas as pd

# Create a 2D NumPy array
np_array = np.random.rand(5, 3)

print("Original NumPy array:")
print(np_array)

# Convert NumPy array to Pandas DataFrame
df = pd.DataFrame(np_array, columns=['A', 'B', 'C'])

print("\nPandas DataFrame:")
print(df)

# Convert Pandas DataFrame back to NumPy array
np_array_from_df = df.to_numpy()

print("\nNumPy array from DataFrame:")
print(np_array_from_df)

"""Exercise 10"""

import numpy as np
import matplotlib.pyplot as plt


# Create a simple dataset:
x = np.arange(50)
y = np.random.randint(0, 101, 50)

# Create the plot
plt.figure(figsize=(12, 6))  # Set the figure size

# Plot the line graph
plt.plot(x, y, color='blue', linewidth=2, label='Random Data')

# Add a trend line (using numpy's polyfit)
z = np.polyfit(x, y, 1)
p = np.poly1d(z)
plt.plot(x, p(x), "r--", linewidth=1, label='Trend Line')

# Customize the plot
plt.title('Line Graph of Random Numbers', fontsize=16)
plt.xlabel('Index', fontsize=12)
plt.ylabel('Random Value', fontsize=12)
plt.legend(fontsize=10)
plt.grid(True, linestyle='--', alpha=0.7)


# Show the plot
plt.tight_layout()
plt.show()